---
# Preparing images for overcloud
- block:
  - name: Get the overcloud images - rhosp-director-images
    yum: name=rhosp-director-images state=latest 
  - name: Get the overcloud images - rhosp-director-images-ipa
    yum: name=rhosp-director-images-ipa state=latest
  become: yes
  become_method: sudo

- name: Create images folder
  file: path=/home/stack/images state=directory mode=0755

- name: Create template folder
  file: path=/home/stack/templates state=directory mode=0755  
  
- name: Untar full overcloud images
  unarchive: src=/usr/share/rhosp-director-images/overcloud-full-latest-8.0.tar dest=/home/stack/images/ remote_src=yes copy=no

- name: Untar full Ironic agent
  unarchive: remote_src=yes src=/usr/share/rhosp-director-images/ironic-python-agent-latest-8.0.tar dest=/home/stack/images/ copy=no

- name: Copy the scripts to upload the overcloud images
  template: src=overcloud_setup_images.j2 dest=/home/stack/overcloud_setup_images.sh owner=stack mode=0755 force=no
  register: cp_result

- name: Load the overcloud images - run the overcloud_setup_images.sh script
  shell: /home/stack/overcloud_setup_images.sh > overcloud_setup_images.log 2>&1
  when: cp_result.changed

- name: Get stack private key
  shell: echo "$(cat /home/stack/.ssh/id_rsa)"
  register: stack_priv

- name: Create the json file
  template: src=instackenv_json.j2 dest=/home/stack/instackenv.jsonorig mode=0644
  vars:
    stack_pkey: "{{ stack_priv.stdout }}"
  register: create_json

- block:
  - name: Run the jq
    shell: jq . /home/stack/instackenv.jsonorig > ~/instackenv.json
  - name: Import baremetal nodes to ironic
    shell: . ~/stackrc && openstack baremetal import --json /home/stack/instackenv.json
  - name: configure boot
    shell: . ~/stackrc && openstack baremetal configure boot
  when: create_json.changed

- name: determine network UUID
  shell: . ~/stackrc && neutron subnet-list -f csv -F id --quote none | grep -v id
  changed_when: false
  register: neutron_uuid
- name: configure DNS for provisioning network
  shell: . ~/stackrc && neutron subnet-update "{{ neutron_uuid.stdout }}" --dns-nameserver {{ host_net_default_ip }}
  when: neutron_uuid.stdout_lines|length == 1

- name: delete ironic flavors using nova due to the bug preventing ironic to delete a flavor
  #https://bugzilla.redhat.com/show_bug.cgi?id=1317312
  shell: . ~/stackrc && nova flavor-delete {{ item }}
  ignore_errors: True
  with_items:
    - compute
    - control
    - baremetal

- name: configure ironic flavors
  shell: >
    . ~/stackrc && openstack flavor create --id auto
    --ram {{ flavors[item].ram }}
    --disk {{ flavors[item].disk }}
    --vcpus {{ flavors[item].cpu }}
    {{ item }}
  with_items:
    - compute
    - control
    - baremetal
- name: adapt ironic flavors (and match flavor to node profile)
  shell: >
    . ~/stackrc && openstack flavor set
    --property "cpu_arch"="x86_64"
    --property "capabilities:boot_option"="local"
    {{ item }}
  with_items:
    - compute
    - control
    - baremetal

# Now ready for introspection
- name: discover nodes - bulk introspection
  shell: . ~/stackrc &&  openstack baremetal introspection bulk start

# 
- name: update control nodes with flavor
  shell: >
    . ~/stackrc && ironic node-update \
    $(ironic port-show --address {{ hostvars[item].net.mac }} |  awk '/node_uuid/{ print $4 }') \
    add properties/capabilities='profile:control,boot_option:local'
  with_items: "{{ groups['osp8-control'] }}"
- name: update compute nodes with flavor
  shell: >
    . ~/stackrc && ironic node-update \
    $(ironic port-show --address {{ hostvars[item].net.mac }} |  awk '/node_uuid/{ print $4 }') \
    add properties/capabilities='profile:compute,boot_option:local'
  with_items: "{{ groups['osp8-compute'] }}"

- name: update ceph nodes with flavor
  shell: >
    . ~/stackrc && ironic node-update \
    $(ironic port-show --address {{ hostvars[item].net.mac }} |  awk '/node_uuid/{ print $4 }') \
    add properties/capabilities='profile:baremetal,boot_option:local'
  with_items: "{{ groups['osp8-ceph'] }}"
  when: with_storage

